# A Simple Scheduler, with I/O

This is part 2 of the scheduler assignment. You will modify your solution to the previous assignment to support I/O operations by the Jobs. As before, the end result should be a Gannt chart based on the actual running times of the threads.

### The Details:

By completing the previous assignment you should already have most of the major parts completed for this assignment, so there shouldn't be all that much code you have to write. Instead, you're going to have to modify your existing code a bit. Notably, you'll have to make more use of your `Timer` objects and interrupts.

### Input File:

The input file will be named [scheduleInput.txt][1], as before, but is a bit more complicated in this assignment. Each line of input is now of the form:

*jobID delayTillSubmission CPUburst [IOburst CPUburst]* *

Again, the first argument will be an integer, and this must somehow be used in the name of the Job (how is up to you). The second argument is the number of milliseconds that should elapse from the submission of the Job corresponding to the previous input line until this Job is submitted to the `SystemSimulator` via `AddNewProcess`. (If this is the first line of the file, then *delayTillSubmission* should be measured from the start time of the `SystemSimulator` itself.

The syntax of the above statement is borrowed from the help pages in Unix: the square brackets indicate optional arguments. The asterix is the **Kleene Star**, such as is found in regular expressions, representing 0 or more repetitions. In other words, the input lines are the same as in the previous assignment but with the possibility of any number of pairs of *IOburst* and *CPUburst* lengths at the end of each line, specified as integers. [Here is a sample input file][2]. (As before, the times are all given in milliseconds.) Your Job threads should run until their current *CPUburst* is complete (again, not counting time spent on the `readyQ`), and at that point begin an *IOburst*, during which time another Job may be able to run. Upon completing the *IOburst*, the Job should be placed on the `readyQ`. (You may need to interrupt the sleeping scheduler if there are no Jobs currently running.)

[Here is the output that might be generated by running on that input][3].

### Adding Simulated Input

Add a method to the `SystemSimulator` class called *doIO(int msec)*. This will act as a system call that your Job class should invoke when it is time for a simulated IO operation. The argument will specify the duration of the IO operation.

Your solution should allow for another Job to run while the IO operation completes. As with the first project, your solution should allow for only one of either the kernel or any Job thread to be runing at a time. You shouldn't have two Jobs running at the same time. At most one Job should be running, with the remainder (if any) either on the ready queue, or on a data structure of your choice for storing the Jobs that are awaiting their IO completion.

When a Job's IO completes it should be placed back onto the ready queue. You'll need to alter the `makeRun()`, because now the ready queue will contain Job's that have never started, as well as those that were previously started, but did an IO and were then placed back on the ready queue.

Your solution should use a simple Thread class, `IODevice` to simulate the IO device. These will act like a simpler version of the `Submittor` class. They will sleep for the duration of the IO, and when they awaken, they will place their particular Job thread back onto the ready queue. As with the submittor thread, its okay for them to be running simultaneosly with other threads.

The potentially tricky part is getting the Job thread to block after it creates and starts its `IODevice`, but not before it sends a *signal()* to its `Condition` so that the kernel Thread can resume, possibly to start (or restart) the next Job thread from the ready queue. There are several solutions, which might use either *sleep()* and *interrupt()*, or *wait()* and *notify()*, or `RentrantLocks` (with *await()* and *signal()*).

### Testing Your Code

You should submit all of your java files as usual. As with the previous project I will provide my own `WorkFactory` class that provides a zero argument *createWork()* method.

I will supply an input file, named **scheduleInput.txt**, sconforming to the syntax described above. I will run your program and examine the resulting Gannt chart.

### To Hand In:

Submit your code to the drop box, along with a text file containing the console output of your program running the example input file.

### Hints:

See my suggested [path to victory][4]!

If you decide to use *sleep()* in combination with *interrupt()*, you might want to check out this [short tutorial on interrupts][5].

As I mentioned in the previous project, you may want to use Java's `StreamTokenizer` class to parse the lines from the input file. Alternatively, you can use *String.split(" ")* to break each input line into constituent substrings.

[This link is to a document explaining the potential for null reference exceptions resulting from invoking methods on "dead" threads][6].

[1]: src/scheduleInput.txt
[2]: src/scheduleInput.txt
[3]: src/InputOutput.md
[4]: src/path_to_victory.md
[5]: src/interrupts.md
[6]: src/null_references.md